PL/T 是解释性语言。

## **作用域规则及内存模型**
PL/T 遵循词法作用域规则以及环境模型，寻址时依据词法上下文。为了保证按照词法作用域寻址，分析语义时就建立了环境模型模拟寻址操作。

## **类型系统**
PL/T 的类型系统与 Python、Scheme 相似，为动态类型系统，即变量的类型推迟到运行时才明确。设计类型系统的时候我想了很久，我既希望它足够灵活，用 PL/T 编程的时候不要受到太多类型上的限制，又希望能在静态检查的时候发现尽可能多的类型错误。事实证明这两者就是鱼与熊掌，要想够灵活，就**必须**把一些内容留到运行时检查。现在能做到的是“尽量检查”，也就是能在编译期确定的类型就在编译期检查，否则留到运行时由虚拟机来判断。同时保留两种特殊的类型：decided 和 unknown。

如果声明变量的同时给它赋值，且赋值表达式的类型是已知的，那么变量的类型就是赋值表达式的类型。如果声明时没有给它赋值、或赋值表达式的值也是 unknown 的，那么它的类型就是 unknown。但为了放松限制，声明变量的时候可以不给它确定类型，而由 read 语句来确定它的类型，此时它的类型就已经确定了。但是编译时当然不知道 read 进来的是什么，为了表示这种已经确定是有类型，但又不知道具体是什么类型的情况，就用“decided”来表示。最后实现了一了说得好听是“动静结合”，说得难听是“不伦不类”的类型系统- -

## **实体表示**
在 PL/T 中，变量、函数均为同等实体，以此实现 first-class function。

## **指令集**
指令由操作码，操作数，以及源文件地址构成- -

## **表达式**
PL/T 全部采用前缀表达式，这样递归下降解析语法的时候就方便得多得多。

## **语法**
<pre><code>
condition = ident | "true | "false " |
           "(" ["="|"#"|"<"|"<="|">"|">="] arithmetic arithmetic ")" |
           "(" "not" condition ")" | "(" ["and"|"or"] condition { condition } ")".

arithmetic = ident | number |
             "(" ["+"|"-"|"*"|"/"] arithmetic { arithmetic } ")".

expression = condition | arithmetic.
</code></pre>
