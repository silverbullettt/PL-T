PL/T 是解释性语言。

## **作用域规则及内存模型**
PL/T 遵循词法作用域规则以及环境模型，寻址时依据词法上下文。为了保证按照词法作用域寻址，分析语义时就建立了环境模型模拟寻址操作。

## **类型系统**
PL/T 的类型系统与 Python、Scheme 相似，为动态类型系统，即变量的类型推迟到运行时才明确。设计类型系统的时候我想了很久，我既希望它足够灵活，用 PL/T 编程的时候不要受到太多类型上的限制，又希望能在静态检查的时候发现尽可能多的类型错误。事实证明这两者就是鱼与熊掌，要想够灵活，就**必须**把很多检查留到运行时。现在能做到的是“尽量检查”，也就是能在编译期确定的类型就在编译期检查，否则留到运行时由虚拟机来判断。同时保留一种特殊的类型 **unknown**。

如果声明变量的同时给它赋值，且赋值表达式的类型是已知的，那么变量的类型就是赋值表达式的类型。如果声明时没有给它赋值、或赋值表达式的值也是 unknown 的，那么它的类型就是 unknown。凡是 unknown 的变量或表达式，均不在编译期检查类型（也根本没法检查），但会在运行时被检查，一旦发现类型错误，立即挂掉。最后实现了一了说得好听是“动静结合”，说得难听是“不伦不类”的类型系统- -

变量的类型信息一路传递到运行时，所以我的 PL/T 可以非常容易地实现**反射**。

## **实体表示**
在 PL/T 中，变量、函数均为同等实体，以此实现 **first-class function**。

## **指令集**
指令由操作码，操作数，以及源文件地址构成- -

## **表达式**
PL/T 全部采用前缀表达式，递归下降解析语法的时候方便很多。

## **语法**
<pre><code>
condition = ident | "true | "false " |
           "(" ["="|"#"|"<"|"<="|">"|">="] arithmetic arithmetic ")" |
           "(" "not" condition ")" | "(" ["and"|"or"] condition { condition } ")".

arithmetic = ident | number |
             "(" ["+"|"-"|"*"|"/"] arithmetic { arithmetic } ")".

expression = condition | arithmetic.
</code></pre>
